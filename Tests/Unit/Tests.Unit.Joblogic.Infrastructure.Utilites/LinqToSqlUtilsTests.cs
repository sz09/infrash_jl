using FluentAssertions;
using JobLogic.Infrastructure.UnitTest;
using JobLogic.Infrastructure.Utilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Linq;

namespace Tests.Unit.Joblogic.Infrastructure.Utilites
{
    [TestClass]
    public class LinqToSqlUtilsTests
    {
        public class TestObject
        {
            public int Id { get; set; }

            public string Name { get; set; }

            public string searchonme { get; set; }
        }

        private static IQueryable<TestObject> GetQueryable(int size = 100)
        {
            var autoGeneratedItems = ValueGenerator.CreateMany<TestObject>(size).OrderBy(m => m.Id).ToList();
            var mockDbSet = autoGeneratedItems.ToMockDbSet();
            return mockDbSet.Object.AsQueryable();
        }

        [TestMethod]
        public void Paginate_Where_PageSize_Is_IntMaxValue_Should_Return_AllItems()
        {
            // Arrange
            const int pageSize = int.MaxValue;
            const int expectedCount = 700;
            var itemsQueryable = GetQueryable(expectedCount);

            // Act
            var actual = itemsQueryable.Paginate(1, pageSize);

            // Assert
            actual.Count().Should().Be(expectedCount);
        }

        [TestMethod]
        public void Paginate_Where_PageSize_Is_GreaterThan_50_Should_Return_50Items()
        {
            // Arrange
            const int pageSize = 51;
            const int expectedCount = 50;
            var itemsQueryable = GetQueryable(100);

            // Act
            var actual = itemsQueryable.Paginate(1, pageSize);

            // Assert
            actual.Count().Should().Be(expectedCount);
        }

        [TestMethod]
        public void Paginate_Where_PageIndex_Is_LessThan_1_Should_Return_FirstPage()
        {
            // Arrange
            const int expectedCount = 5;
            var itemsQueryable = GetQueryable(25);

            // Act
            var actual = itemsQueryable.Paginate(0, expectedCount);

            // Assert
            actual.Count().Should().Be(expectedCount);

            var expectedIds = itemsQueryable.Take(expectedCount).Select(m => m.Id);
            var actualIds = actual.Select(m => m.Id);

            actualIds.SequenceEqual(expectedIds).Should().BeTrue();
        }

        [TestMethod]
        public void FilterBySearchTerm_Where_AllMatch_Should_Return_100Items()
        {
            // Arrange
            const int expectedCount = 100;
            var itemsQueryable = GetQueryable(expectedCount);
            const string searchTerm = nameof(TestObject.searchonme);

            // Act
            var actual = itemsQueryable.FilterBySearchTerm(searchTerm,
                (current, filter) => current.Where(m => m.searchonme.Contains(filter)));

            // Assert
            actual.Count().Should().Be(expectedCount);
        }

        [TestMethod]
        public void FilterBySearchTerm_Where_NoneMatch_Should_Return_0Items()
        {
            // Arrange
            const int expectedCount = 100;
            var itemsQueryable = GetQueryable(expectedCount);
            const string searchTerm = "magnemite";

            // Act
            var actual = itemsQueryable.FilterBySearchTerm(searchTerm,
                (current, filter) => current.Where(m => m.searchonme.Contains(filter)));

            // Assert
            actual.Should().BeEmpty();
        }

        [TestMethod]
        public void FilterBySearchTerm_Where_SomeMatch_Should_Return_SomeItems()
        {
            // Arrange
            const int expectedCount = 100;
            var itemsQueryable = GetQueryable(expectedCount);

            // Not beautiful, but guarantees we always pick a search term which exists in at least one item
            var firstString = itemsQueryable.First().searchonme;
            var rng = new Random();
            var guaranteedCharacter = firstString[rng.Next(firstString.Length)];
            var searchTerm = guaranteedCharacter.ToString();

            // Act
            var actual = itemsQueryable.FilterBySearchTerm(searchTerm,
                (current, filter) => current.Where(m => m.searchonme.Contains(filter)));

            // Assert
            actual.Should().NotBeEmpty();
        }
    }
}
